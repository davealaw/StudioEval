{"id": "cs_001", "question": "Which statement about C# value and reference types is correct?", "choices": {"A": "All value types live on the stack", "B": "Value types can be stored inline (e.g., inside objects) or on the stack; reference types are heap-allocated", "C": "Reference types can be stored on the stack", "D": "Both are always heap-allocated"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_002", "question": "Which are value types in .NET?", "choices": {"A": "class, string, delegate", "B": "struct, enum, decimal", "C": "interface, array", "D": "string, array"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_003", "question": "What is boxing in .NET?", "choices": {"A": "Converting any type to string", "B": "Copying a value type into a new object on the heap as System.Object", "C": "Inlining a reference type", "D": "Encrypting a value type"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_004", "question": "Which operation causes unboxing?", "choices": {"A": "Casting object holding a boxed int back to int", "B": "Casting string to object", "C": "Calling ToString() on an int", "D": "Pinning an object"}, "answer": "A", "difficulty": "easy"}
{"id": "cs_005", "question": "Which type is a reference type?", "choices": {"A": "string", "B": "int", "C": "decimal", "D": "bool"}, "answer": "A", "difficulty": "easy"}
{"id": "cs_006", "question": "Arrays in .NET are:", "choices": {"A": "Always value types", "B": "Reference types whose elements can be value or reference types", "C": "Unmanaged types", "D": "Immutable by definition"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_007", "question": "Excessive boxing can hurt performance because:", "choices": {"A": "It disables JIT optimizations", "B": "It allocates on the heap and adds GC pressure", "C": "It forces synchronous I/O", "D": "It pins memory"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_008", "question": "Which avoids boxing when formatting numeric values?", "choices": {"A": "object o = 5; o.ToString()", "B": "string.Format(\"{0}\", (object)5)", "C": "5.ToString(CultureInfo.InvariantCulture)", "D": "(object)5 == null"}, "answer": "C", "difficulty": "hard"}
{"id": "cs_009", "question": "Generic variance in C# allows 'out' (covariance) and 'in' (contravariance) on:", "choices": {"A": "Classes only", "B": "Interfaces and delegates", "C": "Structs only", "D": "All generic types"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_010", "question": "Which interface is covariant in its type parameter?", "choices": {"A": "IList<T>", "B": "IEnumerable<T>", "C": "ICollection<T>", "D": "List<T>"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_011", "question": "Which delegate is contravariant in its parameter type?", "choices": {"A": "Func<T, TResult>", "B": "Action<T>", "C": "Predicate<T>", "D": "EventHandler<T>"}, "answer": "A", "difficulty": "medium"}
{"id": "cs_012", "question": "Why is IList<T> invariant?", "choices": {"A": "Because it exposes only read operations", "B": "Because it allows both reads and writes, which can violate type safety if varied", "C": "Because all interfaces are invariant", "D": "Because T is unconstrained"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_013", "question": "Which is true about where constraints on generics?", "choices": {"A": "'where T : class' means T must be a reference type", "B": "'where T : struct' allows Nullable<T>", "C": "Constraints are enforced only at runtime", "D": "'new()' constraint allows any constructor signature"}, "answer": "A", "difficulty": "easy"}
{"id": "cs_014", "question": "What does 'default' produce for an unconstrained generic T?", "choices": {"A": "null always", "B": "zero always", "C": "null for reference types and zero-bit pattern for value types", "D": "Throws at runtime"}, "answer": "C", "difficulty": "medium"}
{"id": "cs_015", "question": "Given IEnumerable<string> s = new List<string>();, which assignment is valid due to covariance?", "choices": {"A": "IEnumerable<object> o = s;", "B": "ICollection<object> o = s;", "C": "IList<object> o = (IList<object>)s;", "D": "List<object> o = (List<object>)s;"}, "answer": "A", "difficulty": "hard"}
{"id": "cs_016", "question": "Most LINQ operators like Where/Select on IEnumerable<T> are:", "choices": {"A": "Immediate execution", "B": "Deferred execution until enumeration", "C": "Compile-time only", "D": "Parallel by default"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_017", "question": "Which LINQ call forces immediate execution?", "choices": {"A": "Where", "B": "Select", "C": "ToList", "D": "SelectMany"}, "answer": "C", "difficulty": "easy"}
{"id": "cs_018", "question": "IQueryable<T> differs from IEnumerable<T> primarily because:", "choices": {"A": "It stores results in memory", "B": "It represents expression trees that a provider can translate (e.g., to SQL)", "C": "It is thread-unsafe", "D": "It is only for XML"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_019", "question": "Which statement about IEnumerable vs IQueryable is correct?", "choices": {"A": "IEnumerable queries are executed by providers like databases", "B": "IQueryable can translate expression trees so filters can run server-side", "C": "IQueryable always executes in memory", "D": "They behave identically in all LINQ providers"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_020", "question": "Calling Count() on an IEnumerable<T> sequence:", "choices": {"A": "Is deferred until you iterate later", "B": "Is an immediate terminal operation that enumerates to count items", "C": "Returns without enumeration", "D": "Requires parallelism"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_021", "question": "Which is a pitfall of multiple enumeration of an IEnumerable<T>?", "choices": {"A": "It always caches automatically", "B": "It may re-run expensive queries or re-read streams each time", "C": "It throws on second enumeration", "D": "It mutates the source"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_022", "question": "Which operator materializes the sequence into memory?", "choices": {"A": "AsEnumerable", "B": "ToArray", "C": "Where", "D": "Select"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_023", "question": "SelectMany is typically used to:", "choices": {"A": "Filter items", "B": "Project each item into a sequence and flatten the results", "C": "Sort items", "D": "Group items by key"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_024", "question": "What does 'async' modify in C#?", "choices": {"A": "It creates a new thread", "B": "It enables 'await' inside the method and transforms the method into a state machine", "C": "It disables exceptions", "D": "It forces synchronous execution"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_025", "question": "'async void' should generally be used:", "choices": {"A": "For any asynchronous method", "B": "Only for event handlers", "C": "For library methods to hide tasks", "D": "To improve performance"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_026", "question": "What does ConfigureAwait(false) do?", "choices": {"A": "Cancels the task if it runs too long", "B": "Continues after await without capturing the current context", "C": "Forces continuation on UI thread", "D": "Switches to thread pool before awaiting"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_027", "question": "Blocking on async code with .Result or .Wait() can deadlock primarily because:", "choices": {"A": "Tasks cannot complete without Dispose", "B": "Continuation tries to resume on a captured context that is blocked", "C": "Tasks need STA threads only", "D": "The JIT forbids it"}, "answer": "B", "difficulty": "hard"}
{"id": "cs_028", "question": "Task.WhenAll(a,b) returns:", "choices": {"A": "A Task that completes when both finish; exceptions aggregate", "B": "The result of the fastest task only", "C": "A canceled task if any cancels, otherwise default", "D": "A list of tasks unawaited"}, "answer": "A", "difficulty": "easy"}
{"id": "cs_029", "question": "Which is true about ValueTask vs Task?", "choices": {"A": "ValueTask is always better", "B": "ValueTask can avoid allocations when results are often synchronous but has usage caveats (must not be awaited multiple times)", "C": "ValueTask can be awaited many times safely", "D": "Task cannot represent completed results"}, "answer": "B", "difficulty": "hard"}
{"id": "cs_030", "question": "In ASP.NET Core, capturing a SynchronizationContext is typically:", "choices": {"A": "Required to avoid crashes", "B": "Not applicable; it usually doesn't have a special UI context to capture", "C": "Always identical to WinForms behavior", "D": "Forces single-threaded model"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_031", "question": "Which is the recommended pattern to cancel async operations?", "choices": {"A": "Throw ThreadAbortException", "B": "Pass and observe CancellationToken", "C": "Use GC to stop tasks", "D": "Use volatile flags only"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_032", "question": "What happens if an exception is thrown inside an async Task method and not caught?", "choices": {"A": "It is lost", "B": "It crashes the process immediately", "C": "It is captured and surfaces when the Task is awaited", "D": "It converts to return null"}, "answer": "C", "difficulty": "easy"}
{"id": "cs_033", "question": "'using' statement in C# desugars to:", "choices": {"A": "try/catch", "B": "try/finally with Dispose() in finally", "C": "lock statement", "D": "GC.SuppressFinalize"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_034", "question": "IAsyncDisposable is typically used with:", "choices": {"A": "using", "B": "await using", "C": "lock", "D": "fixed"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_035", "question": "Finalizers (~Type) are mainly for:", "choices": {"A": "Releasing managed memory", "B": "Releasing unmanaged resources if Dispose wasn't called", "C": "Faster GC", "D": "Optimizing JIT"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_036", "question": "Which is generally true about GC.Collect()?", "choices": {"A": "It should be called frequently in production", "B": "It forces a collection and is usually discouraged unless diagnosing", "C": "It compiles code faster", "D": "It disables finalizers"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_037", "question": "The Large Object Heap (LOH) in .NET contains objects typically:", "choices": {"A": "> 85,000 bytes (approximate threshold)", "B": "> 8,500 bytes", "C": "> 1 MB only", "D": "Only strings"}, "answer": "A", "difficulty": "hard"}
{"id": "cs_038", "question": "Which ensures mutual exclusion across threads for critical sections?", "choices": {"A": "lock (Monitor)", "B": "volatile", "C": "yield return", "D": "params"}, "answer": "A", "difficulty": "easy"}
{"id": "cs_039", "question": "What does 'volatile' guarantee on a field?", "choices": {"A": "Atomicity for all operations", "B": "Visibility of reads/writes and ordering with respect to that variable", "C": "Mutual exclusion", "D": "No cache usage"}, "answer": "B", "difficulty": "hard"}
{"id": "cs_040", "question": "Which operation is atomic for 32-bit int fields on 32-bit and 64-bit CLR?", "choices": {"A": "int++", "B": "Interlocked.Increment(ref x)", "C": "x = x + 1", "D": "x *= 2"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_041", "question": "Re-throwing an exception with 'throw;' (no variable) preserves:", "choices": {"A": "Original stack trace", "B": "Replaces the stack trace", "C": "Swallows the error", "D": "Converts to AggregateException"}, "answer": "A", "difficulty": "medium"}
{"id": "cs_042", "question": "Exception filters ('catch (Ex) when (cond)') run:", "choices": {"A": "After the catch block executes", "B": "Before the exception is caught to test a condition", "C": "Only in release builds", "D": "Only on UI thread"}, "answer": "B", "difficulty": "hard"}
{"id": "cs_043", "question": "'finally' blocks execute:", "choices": {"A": "Only when no exception occurs", "B": "Only when an exception occurs", "C": "Regardless of whether an exception occurs", "D": "Only on Windows"}, "answer": "C", "difficulty": "easy"}
{"id": "cs_044", "question": "Which is recommended for creating custom exceptions?", "choices": {"A": "Inherit from System.ApplicationException", "B": "Inherit from System.Exception (or a suitable subclass) and make it serializable", "C": "Use non-exception error codes only", "D": "Always inherit from System.SystemException"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_045", "question": "Aggregating multiple exceptions from parallel tasks typically uses:", "choices": {"A": "ExceptionDispatchInfo", "B": "AggregateException", "C": "OperationCanceledException", "D": "NotSupportedException"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_046", "question": "C# 'record' types by default provide:", "choices": {"A": "Reference equality only", "B": "Value-based equality and 'with' expressions for non-destructive mutation", "C": "No equality members", "D": "Deep immutability of all fields"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_047", "question": "Which is true about events declared with 'event'?", "choices": {"A": "They expose the underlying delegate for direct invocation externally", "B": "They restrict add/remove accessors; only the declaring type can raise the event", "C": "They are static only", "D": "They cannot be multicast"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_048", "question": "Multicast delegates in C#:", "choices": {"A": "Invoke their invocation list in order; return value is from the last delegate", "B": "Return all results as an array automatically", "C": "Cannot be combined with '+'", "D": "Are ordered randomly"}, "answer": "A", "difficulty": "hard"}
{"id": "cs_049", "question": "Nullable reference types (NRTs) in C# enable:", "choices": {"A": "Runtime null checks only", "B": "Compile-time flow analysis and annotations to warn about possible null dereferences", "C": "Eliminating nulls at runtime", "D": "Automatic non-null default values"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_050", "question": "Pattern matching 'is' expressions in modern C# allow:", "choices": {"A": "Only type checks", "B": "Type checks plus property/positional patterns and relational patterns in switch expressions", "C": "Only constant patterns", "D": "Are limited to switch statements"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_051", "question": "Which comparison avoids culture-specific surprises when comparing ASCII identifiers?", "choices": {"A": "string.Equals(a,b)", "B": "string.Equals(a,b,StringComparison.Ordinal)", "C": "string.Compare(a,b) == 0", "D": "a.ToLower()==b.ToLower()"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_052", "question": "String interning in .NET means:", "choices": {"A": "All strings are always interned", "B": "String literals are interned; runtime strings can be interned via String.Intern", "C": "Interning is deprecated", "D": "Only short strings are interned"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_053", "question": "For repeated concatenation in a loop, the recommended approach is:", "choices": {"A": "Using '+' in each iteration", "B": "StringBuilder", "C": "string.Concat with params each time", "D": "string.Format every iteration"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_054", "question": "DateTime.Now vs DateTime.UtcNow: which is generally recommended for timestamps stored and compared across systems?", "choices": {"A": "DateTime.Now", "B": "DateTime.UtcNow", "C": "Either; identical", "D": "DateTime.Today"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_055", "question": "Which best represents an absolute point in time unambiguous across time zones?", "choices": {"A": "DateTime with Kind=Unspecified", "B": "DateTimeOffset", "C": "DateTime.Now", "D": "TimeSpan"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_056", "question": "Why is Stopwatch preferred over DateTime for measuring elapsed time?", "choices": {"A": "Stopwatch uses high-resolution monotonic clock", "B": "Stopwatch returns UTC", "C": "DateTime is faster", "D": "Stopwatch is culture-aware"}, "answer": "A", "difficulty": "easy"}
{"id": "cs_057", "question": "For cryptographically secure random bytes, use:", "choices": {"A": "System.Random", "B": "Guid.NewGuid", "C": "System.Security.Cryptography.RandomNumberGenerator", "D": "new Random(42)"}, "answer": "C", "difficulty": "easy"}
{"id": "cs_058", "question": "System.Random in .NET (before .NET 6) is:", "choices": {"A": "Thread-safe for concurrent Next() from multiple threads", "B": "Not thread-safe; use separate instances per thread or locks", "C": "Cryptographically secure", "D": "Seeded with hardware entropy by default"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_059", "question": "Best practice for HttpClient usage in long-lived apps is to:", "choices": {"A": "Create/dispose a new HttpClient per request", "B": "Reuse a single HttpClient or use HttpClientFactory to avoid socket exhaustion", "C": "Use WebClient instead", "D": "Always set Timeout=Infinite"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_060", "question": "Which statement about File.ReadAllText vs FileStream is correct?", "choices": {"A": "ReadAllText loads entire file into memory; streaming reads incrementally", "B": "FileStream always reads entire file", "C": "ReadAllText is asynchronous", "D": "FileStream cannot be used with using"}, "answer": "A", "difficulty": "easy"}
{"id": "cs_061", "question": "typeof(T) vs obj.GetType():", "choices": {"A": "typeof(T) requires an instance; GetType works only for value types", "B": "typeof(T) gets compile-time type; GetType gets runtime type of instance", "C": "Both return the same at compile time", "D": "GetType is faster"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_062", "question": "Custom attributes in .NET are defined by:", "choices": {"A": "Inheriting from System.Attribute", "B": "Implementing IAttribute", "C": "Decorating with [Custom] only", "D": "Using reflection emit only"}, "answer": "A", "difficulty": "easy"}
{"id": "cs_063", "question": "The null-forgiving operator (!) does what?", "choices": {"A": "Throws if value is null", "B": "Suppresses compiler nullability warnings on the preceding expression", "C": "Converts null to default", "D": "Checks for null at runtime"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_064", "question": "Which operator returns the right-hand operand only when the left-hand is null?", "choices": {"A": "||", "B": "??", "C": "?:", "D": "?.:"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_065", "question": "The ?. operator:", "choices": {"A": "Throws on null", "B": "Short-circuits member access if receiver is null and returns null", "C": "Casts to nullable", "D": "Coalesces to default"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_066", "question": "Which is valid modern C# pattern matching?", "choices": {"A": "switch with only constant patterns", "B": "Type, property, relational, and 'when' guard patterns", "C": "Type checks only via 'is'", "D": "Pattern matching only in statements, not expressions"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_067", "question": "A switch expression differs from a switch statement by:", "choices": {"A": "Allowing fall-through by default", "B": "Being an expression returning a value with exhaustive arms", "C": "Not supporting patterns", "D": "Requiring break in every arm"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_068", "question": "List patterns (C# 12) allow:", "choices": {"A": "Matching sequences by length and element patterns", "B": "Only matching arrays, not lists", "C": "Mutating on match", "D": "Regex-like captures"}, "answer": "A", "difficulty": "hard"}
{"id": "cs_069", "question": "init-only setters enable:", "choices": {"A": "Setting properties only in object initializers or constructors", "B": "Changing properties anytime", "C": "Auto-implemented fields", "D": "Readonly fields at runtime"}, "answer": "A", "difficulty": "medium"}
{"id": "cs_070", "question": "Records provide value-based equality by default; which is true?", "choices": {"A": "Two records with equal state are != by default", "B": "Records use reference equality only", "C": "Records override Equals/GetHashCode based on properties", "D": "Records cannot be inherited"}, "answer": "C", "difficulty": "easy"}
{"id": "cs_071", "question": "ValueTuple ( (int x, int y) ) vs Tuple<T1,T2>:", "choices": {"A": "Both are reference types", "B": "ValueTuple is a struct with better performance and supports deconstruction", "C": "Tuple supports deconstruction; ValueTuple does not", "D": "ValueTuple cannot be generic"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_072", "question": "Span<T> is a:", "choices": {"A": "Reference type for heap data", "B": "ref struct that can point to stack or unmanaged memory; cannot be boxed or captured", "C": "Delegate type", "D": "Thread-only type"}, "answer": "B", "difficulty": "hard"}
{"id": "cs_073", "question": "stackalloc creates:", "choices": {"A": "Heap-allocated arrays", "B": "Stack-allocated memory usable with Span<T>", "C": "Pinned arrays on LOH", "D": "A GC handle"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_074", "question": "Memory<T> differs from Span<T> because:", "choices": {"A": "Memory<T> is a ref struct", "B": "Memory<T> is a heap-friendly wrapper that can be stored and awaited; Span<T> cannot escape the stack", "C": "They are identical", "D": "Memory<T> is unsafe only"}, "answer": "B", "difficulty": "hard"}
{"id": "cs_075", "question": "lock(this) is discouraged because:", "choices": {"A": "It is slower than Monitor.TryEnter", "B": "External code can also lock on the same object, causing deadlocks", "C": "It prevents reentrancy", "D": "It requires unsafe code"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_076", "question": "Which provides atomic increment for an int?", "choices": {"A": "x++", "B": "Interlocked.Increment(ref x)", "C": "Monitor.Pulse", "D": "volatile ++x"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_077", "question": "Thread.Sleep(0) does what?", "choices": {"A": "Sleeps for one millisecond", "B": "Yields the remainder of the thread's time slice", "C": "Blocks for one second", "D": "Spins without yielding"}, "answer": "B", "difficulty": "hard"}
{"id": "cs_078", "question": "Task.Delay vs Thread.Sleep in async methods:", "choices": {"A": "Both block threads", "B": "Task.Delay is non-blocking and schedules continuation; Sleep blocks the thread", "C": "Task.Delay blocks the thread pool thread", "D": "Sleep is non-blocking"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_079", "question": "System.Threading.Channels are used for:", "choices": {"A": "Database connections", "B": "High-performance producer/consumer pipelines with backpressure", "C": "Network sockets only", "D": "UI events only"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_080", "question": "PLINQ AsParallel() by default:", "choices": {"A": "Preserves input order always", "B": "May reorder unless AsOrdered is specified", "C": "Runs on GPU", "D": "Requires IEnumerable<dynamic>"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_081", "question": "Parallel.ForEach should be used carefully with:", "choices": {"A": "CPU-bound workloads that are thread-safe", "B": "I/O-bound workloads on UI thread", "C": "Operations that require thread affinity (e.g., UI)", "D": "Both B and C"}, "answer": "D", "difficulty": "easy"}
{"id": "cs_082", "question": "TaskCompletionSource option RunContinuationsAsynchronously helps to:", "choices": {"A": "Run CPU work faster", "B": "Avoid running continuations inline on the thread that completes the task, reducing reentrancy issues", "C": "Enable cancellation", "D": "Force UI thread usage"}, "answer": "B", "difficulty": "hard"}
{"id": "cs_083", "question": "A safe pattern to complete a TaskCompletionSource is:", "choices": {"A": "SetResult multiple times", "B": "TrySetResult/TrySetException to avoid InvalidOperationException", "C": "Use SetCanceled only", "D": "Never complete it"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_084", "question": "WeakReference allows:", "choices": {"A": "Preventing GC of an object", "B": "Referencing an object without preventing its collection", "C": "Pinning memory", "D": "Faster access"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_085", "question": "GCHandleType.Pinned is used to:", "choices": {"A": "Prevent collection and relocation of an object for interop", "B": "Speed up GC", "C": "Convert objects to stack", "D": "Disable finalizers"}, "answer": "A", "difficulty": "hard"}
{"id": "cs_086", "question": "Which GC generation contains most short-lived objects?", "choices": {"A": "Gen 0", "B": "Gen 1", "C": "Gen 2", "D": "LOH only"}, "answer": "A", "difficulty": "easy"}
{"id": "cs_087", "question": "Overriding Equals without GetHashCode leads to:", "choices": {"A": "No issues", "B": "Inconsistent behavior in hash-based collections", "C": "Compiler error", "D": "Better performance"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_088", "question": "Using [Flags] on an enum enables:", "choices": {"A": "String-based enums", "B": "Bitwise combination semantics for enum values", "C": "Automatic parsing only", "D": "Serialization only"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_089", "question": "HashCode.Combine(a,b,c) helps to:", "choices": {"A": "Create cryptographic hashes", "B": "Create a good distribution GetHashCode for composite types", "C": "Sort objects", "D": "Encrypt fields"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_090", "question": "To build paths in a cross-platform way, use:", "choices": {"A": "String concatenation with '/'", "B": "Path.Combine", "C": "Environment.NewLine", "D": "Directory.GetCurrentDirectory + filename"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_091", "question": "File.OpenRead returns:", "choices": {"A": "A Stream that must be disposed", "B": "A byte[]", "C": "A string", "D": "A TextReader that auto-disposes"}, "answer": "A", "difficulty": "easy"}
{"id": "cs_092", "question": "C# 8 default interface members allow:", "choices": {"A": "Fields in interfaces", "B": "Providing method implementations in interfaces", "C": "Static constructors in interfaces", "D": "Overriding sealed methods"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_093", "question": "Given var a = new int[]{10,20,30,40}; a[^1] is:", "choices": {"A": "10", "B": "20", "C": "30", "D": "40"}, "answer": "D", "difficulty": "easy"}
{"id": "cs_094", "question": "a[1..^1] returns:", "choices": {"A": "[10,20,30,40]", "B": "A slice excluding first and last elements", "C": "[10,40] only", "D": "Last element only"}, "answer": "B", "difficulty": "medium"}
{"id": "cs_095", "question": "Nullable<int> (int?) has HasValue=false means:", "choices": {"A": "Value is 0", "B": "Value is null; GetValueOrDefault() returns default(int)", "C": "Throws on access", "D": "It is boxed"}, "answer": "B", "difficulty": "easy"}
{"id": "cs_096", "question": "Boxing a nullable value type with HasValue=false results in:", "choices": {"A": "A boxed default value", "B": "A boxed null", "C": "A null reference", "D": "A NotSupportedException"}, "answer": "C", "difficulty": "hard"}
{"id": "cs_097", "question": "System.Text.Json by default is:", "choices": {"A": "Case-sensitive for property names unless configured otherwise", "B": "Identical to Newtonsoft.Json in defaults", "C": "Binary serializer", "D": "Culture-specific only"}, "answer": "A", "difficulty": "medium"}
{"id": "cs_098", "question": "To ignore null values during serialization with System.Text.Json, you can set:", "choices": {"A": "JsonSerializerOptions.DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull", "B": "IgnoreNulls=true on JsonSerializer", "C": "[JsonIgnoreNulls] on class", "D": "Use BinaryFormatter"}, "answer": "A", "difficulty": "medium"}
{"id": "cs_099", "question": "AssemblyLoadContext in .NET Core is used for:", "choices": {"A": "UI theming", "B": "Isolating assembly loading/unloading (plugins)", "C": "Parallel GC", "D": "Managing culture info"}, "answer": "B", "difficulty": "hard"}
{"id": "cs_100", "question": "The 'with' expression on records:", "choices": {"A": "Mutates the original object", "B": "Creates a copy with specified properties changed (non-destructive mutation)", "C": "Is only for structs", "D": "Requires reflection"}, "answer": "B", "difficulty": "easy"}