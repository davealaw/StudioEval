{"id": "js_001", "question": "What happens when you access a 'let' variable before its declaration in the same scope?", "choices": {"A": "It returns undefined", "B": "It throws ReferenceError due to the temporal dead zone", "C": "It throws TypeError", "D": "It is hoisted like 'var'"}, "answer": "B", "difficulty": "medium"}
{"id": "js_002", "question": "Which statement about 'var' vs 'let/const' at the top level in browsers is correct?", "choices": {"A": "'var' creates no global properties; 'let/const' do", "B": "'var' creates a property on 'window'; 'let/const' do not", "C": "Both create global properties on 'window'", "D": "Neither affects the global object"}, "answer": "B", "difficulty": "medium"}
{"id": "js_003", "question": "Which variables are hoisted?", "choices": {"A": "'var' only", "B": "'let' and 'const' only", "C": "All declarations are hoisted but 'let/const' are uninitialized (TDZ)", "D": "None are hoisted"}, "answer": "C", "difficulty": "easy"}
{"id": "js_004", "question": "'typeof x' before 'let x' is declared in the same scope will:", "choices": {"A": "Return 'undefined'", "B": "Throw ReferenceError", "C": "Return 'object'", "D": "Return 'number'"}, "answer": "B", "difficulty": "hard"}
{"id": "js_005", "question": "Block scoping means:", "choices": {"A": "'var' variables are limited to the nearest function", "B": "'let/const' variables are limited to the nearest block '{}'", "C": "All variables are global by default", "D": "Only 'const' is block-scoped"}, "answer": "B", "difficulty": "easy"}
{"id": "js_006", "question": "Which declaration is hoisted to the top of its scope with an initialized binding?", "choices": {"A": "Function declaration", "B": "Function expression", "C": "Arrow function expression", "D": "Class declaration"}, "answer": "A", "difficulty": "medium"}
{"id": "js_007", "question": "How does 'this' behave in an arrow function?", "choices": {"A": "Bound dynamically at call-site", "B": "Lexically captured from the enclosing scope", "C": "Always the global object", "D": "Undefined only in strict mode"}, "answer": "B", "difficulty": "easy"}
{"id": "js_008", "question": "'arguments' inside an arrow function refers to:", "choices": {"A": "Its own arguments object", "B": "The outer (enclosing) function's arguments", "C": "Always an empty array", "D": "A special iterator"}, "answer": "B", "difficulty": "medium"}
{"id": "js_009", "question": "What happens when you call 'new' on an arrow function?", "choices": {"A": "Creates a new object as usual", "B": "Throws because arrow functions are not constructible", "C": "Works only in strict mode", "D": "Binds 'this' to the new object"}, "answer": "B", "difficulty": "medium"}
{"id": "js_010", "question": "What is the effect of 'bind' on an arrow function?", "choices": {"A": "It changes 'this' at call time", "B": "It changes both 'this' and 'arguments'", "C": "It has no effect on 'this' of an arrow function", "D": "It only changes 'arguments'"}, "answer": "C", "difficulty": "medium"}
{"id": "js_011", "question": "In methods on objects, when is an arrow function a bad choice?", "choices": {"A": "When you need lexical 'this'", "B": "When you need dynamic 'this' based on the call-site", "C": "When you need access to outer scope", "D": "When you need short syntax"}, "answer": "B", "difficulty": "medium"}
{"id": "js_012", "question": "'instanceof' checks:", "choices": {"A": "Constructor name equality", "B": "Prototype chain: whether prototype appears in object's chain", "C": "Property existence on the instance", "D": "Type equality by 'typeof'"}, "answer": "B", "difficulty": "easy"}
{"id": "js_013", "question": "For a function Foo, 'new Foo()' sets the new object's internal [[Prototype]] to:", "choices": {"A": "Foo.__proto__", "B": "Foo.prototype", "C": "Object.prototype", "D": "null"}, "answer": "B", "difficulty": "medium"}
{"id": "js_014", "question": "Which is true about ES 'class' syntax?", "choices": {"A": "Class declarations are hoisted like functions with initialized binding", "B": "Class declarations are hoisted but uninitialized (TDZ)", "C": "Classes are not hoisted at all", "D": "Classes cannot extend other classes"}, "answer": "B", "difficulty": "medium"}
{"id": "js_015", "question": "Which method defines a property directly on an object with control over enumerability/writability?", "choices": {"A": "Object.assign", "B": "Object.defineProperty", "C": "Object.create", "D": "Reflect.has"}, "answer": "B", "difficulty": "easy"}
{"id": "js_016", "question": "Which correctly creates an object that inherits from 'proto'?", "choices": {"A": "new Object(proto)", "B": "Object.create(proto)", "C": "proto.create()", "D": "Object.assign({}, proto)"}, "answer": "B", "difficulty": "easy"}
{"id": "js_017", "question": "Which statement about '==' vs '===' is correct?", "choices": {"A": "'==' compares without coercion", "B": "'===' allows coercion if types differ", "C": "'===' checks equality without type coercion", "D": "They are identical"}, "answer": "C", "difficulty": "easy"}
{"id": "js_018", "question": "Which value is falsy in JavaScript?", "choices": {"A": "[]", "B": "{}", "C": "\"0\"", "D": "0"}, "answer": "D", "difficulty": "easy"}
{"id": "js_019", "question": "'NaN === NaN' evaluates to:", "choices": {"A": "true", "B": "false", "C": "throws", "D": "undefined"}, "answer": "B", "difficulty": "medium"}
{"id": "js_020", "question": "Which operation returns true?", "choices": {"A": "Object.is(+0, -0)", "B": "+0 === -0", "C": "Number.isNaN(NaN) === false", "D": "Object.is(NaN, NaN)"}, "answer": "D", "difficulty": "hard"}
{"id": "js_021", "question": "In browsers, after synchronous code completes, which callbacks run first?", "choices": {"A": "setTimeout callbacks (macrotasks)", "B": "Promise.then callbacks (microtasks)", "C": "requestAnimationFrame", "D": "I/O callbacks only"}, "answer": "B", "difficulty": "medium"}
{"id": "js_022", "question": "What does 'async' function return?", "choices": {"A": "A generator", "B": "A Promise", "C": "An iterator", "D": "A microtask"}, "answer": "B", "difficulty": "easy"}
{"id": "js_023", "question": "'await' inside an async function does which of the following?", "choices": {"A": "Blocks the event loop", "B": "Pauses the async function and resumes after the Promise settles", "C": "Creates a new thread", "D": "Executes synchronously"}, "answer": "B", "difficulty": "easy"}
{"id": "js_024", "question": "Which is true about 'Promise.all'?", "choices": {"A": "Resolves when any promise resolves", "B": "Resolves to the first resolved value only", "C": "Rejects fast on the first rejection", "D": "Ignores rejections"}, "answer": "C", "difficulty": "medium"}
{"id": "js_025", "question": "Which is true about 'Promise.race'?", "choices": {"A": "Waits for all promises to settle", "B": "Settles as soon as the first promise settles (resolve or reject)", "C": "Only returns the fastest resolved value", "D": "Only returns the fastest rejection"}, "answer": "B", "difficulty": "medium"}
{"id": "js_026", "question": "What happens if an error is thrown inside an async function (without try/catch)?", "choices": {"A": "It crashes the runtime", "B": "It is wrapped as a rejected Promise", "C": "It is ignored", "D": "It becomes a fulfilled Promise with the error"}, "answer": "B", "difficulty": "medium"}
{"id": "js_027", "question": "Which statement about ES Modules (ESM) is correct?", "choices": {"A": "Imports are dynamic by default", "B": "Imports/exports are static and create live bindings", "C": "Default export is mandatory", "D": "ESM cannot be used in Node.js"}, "answer": "B", "difficulty": "medium"}
{"id": "js_028", "question": "In Node.js, which is true about 'import(...)' (dynamic import)?", "choices": {"A": "It returns a module synchronously", "B": "It returns a Promise that resolves to the module namespace object", "C": "It is identical to 'require'", "D": "It only works in browsers"}, "answer": "B", "difficulty": "easy"}
{"id": "js_029", "question": "CommonJS modules primarily export values using:", "choices": {"A": "export default", "B": "export const", "C": "module.exports / exports", "D": "import.meta.exports"}, "answer": "C", "difficulty": "easy"}
{"id": "js_030", "question": "Which import form gathers all named exports into a namespace object?", "choices": {"A": "import defaultName from 'm'", "B": "import * as ns from 'm'", "C": "import {'*' as ns} from 'm'", "D": "const ns = require('m').*"}, "answer": "B", "difficulty": "medium"}
{"id": "js_031", "question": "Which array method returns a new array without mutating the original?", "choices": {"A": "push", "B": "splice", "C": "map", "D": "sort"}, "answer": "C", "difficulty": "easy"}
{"id": "js_032", "question": "What does Object.freeze(obj) do?", "choices": {"A": "Deeply freezes all nested objects", "B": "Shallowly prevents adding/removing/changing properties' writability", "C": "Converts properties to getters", "D": "Prevents enumeration only"}, "answer": "B", "difficulty": "medium"}
{"id": "js_033", "question": "Which spreads properties into a new object (shallow copy)?", "choices": {"A": "Object.assign(target, source) mutates target", "B": "{...source} creates a new object", "C": "JSON.stringify/parse deep-copies all types", "D": "Object.create(source) clones properties"}, "answer": "B", "difficulty": "easy"}
{"id": "js_034", "question": "Which method removes elements without mutating the original array (proposed/modern)?", "choices": {"A": "slice", "B": "toSpliced", "C": "splice", "D": "pop"}, "answer": "B", "difficulty": "hard"}
{"id": "js_035", "question": "Which detects whether an object has an own (non-inherited) property?", "choices": {"A": "'prop' in obj (includes prototype)", "B": "obj.hasOwnProperty('prop')", "C": "Object.prototype.isPrototypeOf(obj)", "D": "Object.setPrototypeOf(obj)"}, "answer": "B", "difficulty": "medium"}
{"id": "js_036", "question": "TypeScript's type system is primarily:", "choices": {"A": "Nominal", "B": "Structural (duck typing)", "C": "Dynamic only", "D": "Dependent"}, "answer": "B", "difficulty": "easy"}
{"id": "js_037", "question": "'unknown' vs 'any' in TypeScript: which is safer and why?", "choices": {"A": "'unknown' is safer; you must narrow before use", "B": "'any' is safer; it forbids all operations", "C": "Both are identical", "D": "'unknown' allows all operations"}, "answer": "A", "difficulty": "medium"}
{"id": "js_038", "question": "'never' in TypeScript denotes:", "choices": {"A": "A type with exactly one value: null", "B": "A type of values that never occur (e.g., function always throws)", "C": "A type alias for undefined", "D": "A top type"}, "answer": "B", "difficulty": "medium"}
{"id": "js_039", "question": "Which narrows a union type at runtime?", "choices": {"A": "typeof / instanceof / 'in' checks", "B": "Comments", "C": "Interfaces only", "D": "Enums only"}, "answer": "A", "difficulty": "easy"}
{"id": "js_040", "question": "What does 'as const' applied to an array literal produce?", "choices": {"A": "string[] (mutable)", "B": "readonly [literal, …] tuple with literal types", "C": "any[]", "D": "never"}, "answer": "B", "difficulty": "medium"}
{"id": "js_041", "question": "'keyof T' produces:", "choices": {"A": "Runtime list of keys", "B": "Union of property names of T", "C": "Intersection of keys of T", "D": "An array of keys"}, "answer": "B", "difficulty": "medium"}
{"id": "js_042", "question": "What does 'Record<K, V>' represent?", "choices": {"A": "Tuple of [K,V]", "B": "Mapped type of keys K to values V", "C": "Union of K and V", "D": "An enum-like type"}, "answer": "B", "difficulty": "easy"}
{"id": "js_043", "question": "Declaration merging applies to:", "choices": {"A": "type aliases", "B": "interfaces and some namespaces", "C": "enums only", "D": "generics only"}, "answer": "B", "difficulty": "medium"}
{"id": "js_044", "question": "Which is true about 'private' in TypeScript classes (not '#private')?", "choices": {"A": "Enforced only at compile time; accessible at runtime via JS", "B": "Enforced at runtime by the VM", "C": "Identical to Java private", "D": "Disallows reflection"}, "answer": "A", "difficulty": "medium"}
{"id": "js_045", "question": "'unknown' is assignable to:", "choices": {"A": "Everything without checks", "B": "Only 'any' and 'unknown' without narrowing", "C": "Only 'never'", "D": "Only object"}, "answer": "B", "difficulty": "hard"}
{"id": "js_046", "question": "Which best describes discriminated unions?", "choices": {"A": "Union types with a common literal property used for narrowing", "B": "Unions of unrelated classes only", "C": "Enums with members", "D": "Intersected generics"}, "answer": "A", "difficulty": "medium"}
{"id": "js_047", "question": "What does 'Pick<T, K>' do?", "choices": {"A": "Removes keys K from T", "B": "Creates a type with only properties K from T", "C": "Makes all props optional", "D": "Makes all props required"}, "answer": "B", "difficulty": "easy"}
{"id": "js_048", "question": "'Omit<T, K>' is equivalent to:", "choices": {"A": "Pick<T, Exclude<keyof T, K>>", "B": "Exclude<T, K>", "C": "Extract<T, K>", "D": "Partial<T>"}, "answer": "A", "difficulty": "hard"}
{"id": "js_049", "question": "What does 'readonly' modifier on array type readonly string[] do?", "choices": {"A": "Prevents pushing/assigning elements", "B": "Sorts the array", "C": "Deep freezes elements", "D": "Forbids iteration"}, "answer": "A", "difficulty": "medium"}
{"id": "js_050", "question": "Which built-in TypeScript utility type removes 'null' and 'undefined' from a union T?", "choices": {"A": "NonNullable<T>", "B": "Required<T>", "C": "Partial<T>", "D": "Exclude<T, null>"}, "answer": "A", "difficulty": "medium"}
{"id": "js_051", "question": "What happens if you reference a class before its declaration in the same scope?", "choices": {"A": "Returns undefined", "B": "Throws ReferenceError due to TDZ", "C": "Silently creates an empty class", "D": "Hoists a usable class"}, "answer": "B", "difficulty": "medium"}
{"id": "js_052", "question": "In a for-loop with 'var i', creating functions inside the loop that use 'i' leads to:", "choices": {"A": "Each function captures its own 'i' value", "B": "All functions share the same function-scoped 'i'", "C": "A SyntaxError", "D": "Block-scoped behavior"}, "answer": "B", "difficulty": "easy"}
{"id": "js_053", "question": "'const obj = {a:1}' means:", "choices": {"A": "Object is deeply immutable", "B": "Binding cannot be reassigned, but properties can change", "C": "Properties are read-only", "D": "Object is frozen automatically"}, "answer": "B", "difficulty": "easy"}
{"id": "js_054", "question": "In strict mode, calling a plain function 'f()' with no receiver sets 'this' to:", "choices": {"A": "global object", "B": "undefined", "C": "f itself", "D": "null"}, "answer": "B", "difficulty": "medium"}
{"id": "js_055", "question": "In browsers, deleting a 'var' global (window.x) usually:", "choices": {"A": "Succeeds and removes it", "B": "Throws TypeError", "C": "Returns false because it's non-configurable", "D": "Converts it to 'let'"}, "answer": "C", "difficulty": "hard"}
{"id": "js_056", "question": "Inside setTimeout(function(){ ... }), what is 'this' by default (non-strict mode in browsers)?", "choices": {"A": "The timer object", "B": "The callback function", "C": "The global object (window)", "D": "Undefined"}, "answer": "C", "difficulty": "medium"}
{"id": "js_057", "question": "Which correctly changes a regular function's 'this' for a single call?", "choices": {"A": "fn.bind(obj)() (permanently)", "B": "fn.call(obj, ...args)", "C": "fn.apply(null, obj)", "D": "new fn(obj)"}, "answer": "B", "difficulty": "easy"}
{"id": "js_058", "question": "Why is an arrow function unsuitable as a method when dynamic 'this' is required?", "choices": {"A": "Arrow functions are slower", "B": "Arrow functions cannot access arguments", "C": "Arrow functions lexically capture 'this'", "D": "Arrow functions cannot return values"}, "answer": "C", "difficulty": "easy"}
{"id": "js_059", "question": "Object.create(null) creates an object that:", "choices": {"A": "Has no prototype and no built-in methods", "B": "Is frozen by default", "C": "Is identical to {}", "D": "Automatically has hasOwnProperty"}, "answer": "A", "difficulty": "medium"}
{"id": "js_060", "question": "Which retrieves the prototype of an object?", "choices": {"A": "obj.prototype", "B": "Object.getPrototypeOf(obj)", "C": "obj.__proto__ only", "D": "Reflect.setPrototypeOf(obj)"}, "answer": "B", "difficulty": "easy"}
{"id": "js_061", "question": "In a class, a public field 'x = 1' is:", "choices": {"A": "Placed on the prototype", "B": "Placed on each instance", "C": "Static by default", "D": "Non-writable by default"}, "answer": "B", "difficulty": "medium"}
{"id": "js_062", "question": "Which statement about getters/setters is correct?", "choices": {"A": "They cannot be defined via Object.defineProperty", "B": "They exist per-instance only", "C": "They can be defined on prototypes to control property access", "D": "They cannot observe assignments"}, "answer": "C", "difficulty": "medium"}
{"id": "js_063", "question": "Which creates a shallow, property-descriptor-aware copy?", "choices": {"A": "Object.assign({}, src)", "B": "{...src}", "C": "Object.create(Object.getPrototypeOf(src), Object.getOwnPropertyDescriptors(src))", "D": "JSON.parse(JSON.stringify(src))"}, "answer": "C", "difficulty": "hard"}
{"id": "js_064", "question": "Which is true of Number.isNaN vs isNaN?", "choices": {"A": "Both coerce; Number.isNaN doesn't exist", "B": "isNaN coerces; Number.isNaN does not coerce", "C": "Number.isNaN coerces; isNaN does not", "D": "Neither detects NaN"}, "answer": "B", "difficulty": "easy"}
{"id": "js_065", "question": "'Object.is(+0, -0)' returns:", "choices": {"A": "true", "B": "false", "C": "undefined", "D": "Throws"}, "answer": "B", "difficulty": "medium"}
{"id": "js_066", "question": "Which expression is true?", "choices": {"A": "NaN === NaN", "B": "Object.is(NaN, NaN)", "C": "Number.isNaN('foo')", "D": "0 === -0 is false"}, "answer": "B", "difficulty": "easy"}
{"id": "js_067", "question": "queueMicrotask(fn) schedules 'fn' to run:", "choices": {"A": "As a macrotask", "B": "As a microtask after the current turn", "C": "Before the current synchronous code ends", "D": "Only in Node.js"}, "answer": "B", "difficulty": "medium"}
{"id": "js_068", "question": "Which is a safe way to run tasks concurrently and collect all results, failing fast on any error?", "choices": {"A": "Promise.all", "B": "Promise.allSettled", "C": "Promise.any", "D": "Promise.race"}, "answer": "A", "difficulty": "medium"}
{"id": "js_069", "question": "What does finally do on a promise chain?", "choices": {"A": "Transforms values", "B": "Runs regardless of resolve/reject and passes through previous value/reason", "C": "Catches only rejections", "D": "Cancels the chain"}, "answer": "B", "difficulty": "easy"}
{"id": "js_070", "question": "Top-level await is supported in:", "choices": {"A": "CommonJS only", "B": "ES Modules", "C": "Both CJS and ESM everywhere", "D": "Nowhere"}, "answer": "B", "difficulty": "medium"}
{"id": "js_071", "question": "An unhandled rejection in a promise will:", "choices": {"A": "Always crash immediately", "B": "Be ignored in all environments", "C": "Trigger 'unhandledrejection' event or warnings depending on environment", "D": "Convert to a resolved promise"}, "answer": "C", "difficulty": "medium"}
{"id": "js_072", "question": "In an async function, 'try { await p } finally { ... }' ensures:", "choices": {"A": "finally runs only if p resolves", "B": "finally runs whether p resolves or rejects", "C": "finally is skipped on rejection", "D": "finally runs before awaiting p"}, "answer": "B", "difficulty": "easy"}
{"id": "js_073", "question": "ESM vs CJS: which is more amenable to tree-shaking?", "choices": {"A": "CJS due to dynamic requires", "B": "ESM due to static structure and live bindings", "C": "They are equally tree-shakeable", "D": "Neither can be tree-shaken"}, "answer": "B", "difficulty": "medium"}
{"id": "js_074", "question": "In ESM, imports are:", "choices": {"A": "Mutable copies", "B": "Live bindings to the exported values", "C": "Frozen values copied at load time", "D": "Aliases with no runtime link"}, "answer": "B", "difficulty": "easy"}
{"id": "js_075", "question": "In Node.js, which file extension/flag helps enable ESM semantics?", "choices": {"A": ".cjs or 'type':'commonjs'", "B": ".mjs or 'type':'module'", "C": ".esm only", "D": "No configuration is needed"}, "answer": "B", "difficulty": "medium"}
{"id": "js_076", "question": "Which returns a new sorted array without mutating the original (modern proposal/standard)?", "choices": {"A": "sort", "B": "toSorted", "C": "splice", "D": "reverse"}, "answer": "B", "difficulty": "medium"}
{"id": "js_077", "question": "Array.isArray([]) returns:", "choices": {"A": "false", "B": "true", "C": "Depends on strict mode", "D": "Throws"}, "answer": "B", "difficulty": "easy"}
{"id": "js_078", "question": "JSON.stringify({a: undefined, b: 2}) outputs:", "choices": {"A": "{\"a\":null,\"b\":2}", "B": "{\"a\":undefined,\"b\":2}", "C": "{\"b\":2}", "D": "{}"}, "answer": "C", "difficulty": "hard"}
{"id": "js_079", "question": "JSON.stringify([1, undefined, 3]) outputs:", "choices": {"A": "[1,null,3]", "B": "[1,undefined,3]", "C": "[1,0,3]", "D": "[1,3]"}, "answer": "A", "difficulty": "medium"}
{"id": "js_080", "question": "structuredClone(obj) compared to JSON serialize/parse:", "choices": {"A": "Refuses all objects", "B": "Supports many types (Map, Set, Date, circular) that JSON cannot", "C": "Is slower and identical in capability", "D": "Mutates the original"}, "answer": "B", "difficulty": "medium"}
{"id": "js_081", "question": "Which converts [ ['a',1], ['b',2] ] into {a:1,b:2}?", "choices": {"A": "Object.entries", "B": "Object.fromEntries", "C": "Object.values", "D": "Map()"}, "answer": "B", "difficulty": "easy"}
{"id": "js_082", "question": "Maps vs Objects: which is correct?", "choices": {"A": "Objects allow any value as key without coercion", "B": "Maps keep insertion order and allow any keys (including objects)", "C": "Maps are slower by design", "D": "Objects iterate keys by sorted order only"}, "answer": "B", "difficulty": "easy"}
{"id": "js_083", "question": "Sets treat NaN values as:", "choices": {"A": "All distinct", "B": "All equal (like Object.is)", "C": "Not allowed", "D": "Coerced to 0"}, "answer": "B", "difficulty": "medium"}
{"id": "js_084", "question": "Type predicates enable which pattern?", "choices": {"A": "Runtime type enforcement", "B": "Functions that narrow types using 'param is T' return type", "C": "Nominal typing", "D": "Erasing types at compile time"}, "answer": "B", "difficulty": "medium"}
{"id": "js_085", "question": "Generic 'T extends U' means:", "choices": {"A": "T equals U", "B": "T is assignable to U (constraint)", "C": "U is assignable to T", "D": "Removes T"}, "answer": "B", "difficulty": "easy"}
{"id": "js_086", "question": "Distributive conditional types distribute over unions when:", "choices": {"A": "T is bare in 'T extends X ? A : B'", "B": "You add 'as const'", "C": "You use 'never'", "D": "They never distribute"}, "answer": "A", "difficulty": "hard"}
{"id": "js_087", "question": "'infer' in conditional types allows:", "choices": {"A": "Runtime reflection", "B": "Capturing a type variable from a position in a type to reuse it", "C": "Creating decorators", "D": "Nominal typing"}, "answer": "B", "difficulty": "medium"}
{"id": "js_088", "question": "Readonly<T> in TypeScript:", "choices": {"A": "Deeply freezes nested objects", "B": "Makes all properties of T readonly (shallow)", "C": "Prevents method calls", "D": "Equivalent to const"}, "answer": "B", "difficulty": "easy"}
{"id": "js_089", "question": "Partial<T> does what?", "choices": {"A": "Removes properties from T", "B": "Makes all properties optional", "C": "Makes all properties required", "D": "Narrows property types"}, "answer": "B", "difficulty": "easy"}
{"id": "js_090", "question": "Required<T> does what?", "choices": {"A": "Forces all properties to be present (non-optional)", "B": "Erases readonly", "C": "Narrows unions", "D": "Removes indexes"}, "answer": "A", "difficulty": "easy"}
{"id": "js_091", "question": "NonNullable<T> removes:", "choices": {"A": "never", "B": "undefined and null from T", "C": "optional modifiers", "D": "functions from T"}, "answer": "B", "difficulty": "medium"}
{"id": "js_092", "question": "Exclude<T, U> vs Extract<T, U>:", "choices": {"A": "Exclude keeps only members assignable to U; Extract removes them", "B": "Exclude removes members assignable to U; Extract keeps them", "C": "They are identical", "D": "They require 'never'"}, "answer": "B", "difficulty": "medium"}
{"id": "js_093", "question": "ReturnType<typeof f> yields:", "choices": {"A": "The type of f's parameters", "B": "The inferred return type of f", "C": "The instance type of f", "D": "A union of f and its arguments"}, "answer": "B", "difficulty": "easy"}
{"id": "js_094", "question": "Parameters<typeof f> yields:", "choices": {"A": "Tuple type of f's parameter types", "B": "Array of runtime arguments", "C": "Any[]", "D": "A mapped type"}, "answer": "A", "difficulty": "easy"}
{"id": "js_095", "question": "InstanceType<typeof C> resolves to:", "choices": {"A": "The constructor type", "B": "The instance type constructed by C", "C": "The prototype type", "D": "never"}, "answer": "B", "difficulty": "medium"}
{"id": "js_096", "question": "Template literal types allow:", "choices": {"A": "Runtime string concatenation only", "B": "Type-level string patterns like `get_${string}`", "C": "Numbers only", "D": "Nominal typing"}, "answer": "B", "difficulty": "easy"}
{"id": "js_097", "question": "'as const' applied to an object literal:", "choices": {"A": "Widens all string/number literals", "B": "Narrows to readonly literal types and readonly arrays/tuples", "C": "Has no effect on types", "D": "Throws at runtime"}, "answer": "B", "difficulty": "medium"}
{"id": "js_098", "question": "'satisfies' operator (TS 4.9+) is useful because:", "choices": {"A": "It asserts at runtime", "B": "It checks that a value conforms to a type without widening the variable's inferred type", "C": "It makes all properties optional", "D": "It enables declaration merging"}, "answer": "B", "difficulty": "medium"}
{"id": "js_099", "question": "Function overloads in TS are written as:", "choices": {"A": "Multiple implementations, one signature", "B": "Multiple call signatures and one implementation signature", "C": "Single signature per implementation", "D": "Only generics, no overloads"}, "answer": "B", "difficulty": "hard"}
{"id": "js_100", "question": "Optional chaining (?.) vs nullish coalescing (??): which is correct?", "choices": {"A": "'?.' returns right-hand if left is falsy; '??' returns right-hand if left is falsy", "B": "'?.' short-circuits on null/undefined for property access; '??' uses right-hand only when left is null/undefined (not other falsy values)", "C": "They are equivalent to '||'", "D": "'??' short-circuits on 0 and ''"}, "answer": "B", "difficulty": "easy"}
