{"id": "py_001", "question": "What is the main pitfall of using a mutable default argument like def f(x, acc=[]): ... ?", "choices": {"A": "A new list is created on each call", "B": "The same list is reused across calls", "C": "It raises a SyntaxError", "D": "It forces pass-by-reference"}, "answer": "B", "difficulty": "medium"}
{"id": "py_002", "question": "Which built-in type is hashable by default if all its elements are hashable?", "choices": {"A": "list", "B": "set", "C": "tuple", "D": "bytearray"}, "answer": "C", "difficulty": "easy"}
{"id": "py_003", "question": "What is the average-time complexity for membership tests (x in s) on a Python set?", "choices": {"A": "O(log n)", "B": "O(n)", "C": "O(1) on average", "D": "O(n log n)"}, "answer": "C", "difficulty": "easy"}
{"id": "py_004", "question": "Which statement about Python dictionaries (3.7+) is correct?", "choices": {"A": "They are unordered", "B": "They preserve insertion order", "C": "Keys must be strings", "D": "They cannot be nested"}, "answer": "B", "difficulty": "easy"}
{"id": "py_005", "question": "Which of the following can be used as a dictionary key without additional work?", "choices": {"A": "list", "B": "set", "C": "tuple of ints", "D": "dict"}, "answer": "C", "difficulty": "easy"}
{"id": "py_006", "question": "Given a nested list L, which copy operation duplicates only the outer list, not inner lists?", "choices": {"A": "copy.deepcopy(L)", "B": "copy.copy(L)", "C": "json.loads(json.dumps(L))", "D": "L[:] followed by deepcopy"}, "answer": "B", "difficulty": "medium"}
{"id": "py_007", "question": "Which comparison is recommended to check for a missing value sentinel in Python?", "choices": {"A": "value == None", "B": "value is None", "C": "None in value", "D": "bool(value) == None"}, "answer": "B", "difficulty": "easy"}
{"id": "py_008", "question": "Tuples are immutable, but which statement is true?", "choices": {"A": "They cannot contain mutable elements", "B": "They are always hashable", "C": "They can contain mutable elements, which affects hashability", "D": "They can be modified via item assignment"}, "answer": "C", "difficulty": "medium"}
{"id": "py_009", "question": "Which statement about range objects is correct?", "choices": {"A": "They store all integers in memory", "B": "They are iterables with constant-memory representation", "C": "They are generators that can be resumed", "D": "They are lists in Python 3"}, "answer": "B", "difficulty": "easy"}
{"id": "py_010", "question": "What do *args and **kwargs collect in a function definition?", "choices": {"A": "*args collects keyword args; **kwargs collects positional", "B": "*args collects positional args; **kwargs collects keyword args", "C": "Both collect keyword args", "D": "Both collect positional args"}, "answer": "B", "difficulty": "easy"}
{"id": "py_011", "question": "How do you declare a keyword-only parameter (no code execution needed)?", "choices": {"A": "Place it before all positional parameters", "B": "Use a single '*' before it in the signature", "C": "Use '&' before it in the signature", "D": "It is not supported"}, "answer": "B", "difficulty": "medium"}
{"id": "py_012", "question": "In a closure within a for-loop, why does every lambda often capture the same final loop variable value?", "choices": {"A": "Python copies values at definition time", "B": "Closures bind variables at call time (late binding)", "C": "Closures are not supported in loops", "D": "Lambda cannot capture variables"}, "answer": "B", "difficulty": "medium"}
{"id": "py_013", "question": "Which technique fixes the late-binding closure issue in loops?", "choices": {"A": "Use nonlocal on the loop variable", "B": "Capture the loop variable as a default parameter in the lambda", "C": "Use global on the loop variable", "D": "Use list comprehension only"}, "answer": "B", "difficulty": "medium"}
{"id": "py_014", "question": "What must a decorator return when applied to a function?", "choices": {"A": "Always the original function", "B": "A callable (often a wrapper) replacing the function", "C": "A context manager", "D": "A class only"}, "answer": "B", "difficulty": "easy"}
{"id": "py_015", "question": "Which statement about default argument evaluation is correct?", "choices": {"A": "Defaults are re-evaluated on each call", "B": "Defaults are evaluated once at function definition time", "C": "Defaults are evaluated when the module is imported", "D": "Defaults are evaluated lazily on first call only"}, "answer": "B", "difficulty": "medium"}
{"id": "py_016", "question": "What does nonlocal do inside nested functions?", "choices": {"A": "Creates a new global variable", "B": "Binds to a name in the nearest enclosing (non-global) scope", "C": "Binds to a module-level variable", "D": "Forces pass-by-reference"}, "answer": "B", "difficulty": "medium"}
{"id": "py_017", "question": "Which is true about positional-only parameters (Python 3.8+)?", "choices": {"A": "They are declared using '/' in the parameter list", "B": "They require '*' marker", "C": "They are the same as keyword-only params", "D": "They are deprecated"}, "answer": "A", "difficulty": "hard"}
{"id": "py_018", "question": "What differentiates an iterator from an iterable in Python?", "choices": {"A": "Iterators define __iter__ only; iterables define __next__ only", "B": "Iterators define __iter__ and __next__; iterables define __iter__ returning an iterator", "C": "They are identical", "D": "Only iterables can be used in for-loops"}, "answer": "B", "difficulty": "medium"}
{"id": "py_019", "question": "A generator function is defined by:", "choices": {"A": "Using return inside a function", "B": "Using yield inside a function", "C": "Using async def", "D": "Using lambda"}, "answer": "B", "difficulty": "easy"}
{"id": "py_020", "question": "What exception signals the natural end of an iterator?", "choices": {"A": "StopIteration", "B": "EOFError", "C": "IndexError", "D": "IterationEnd"}, "answer": "A", "difficulty": "easy"}
{"id": "py_021", "question": "What does 'yield from subgen' do in a generator?", "choices": {"A": "Yields the subgenerator object once", "B": "Delegates iteration to the subgenerator, yielding all its values", "C": "Closes the subgenerator", "D": "Copies values from subgenerator into a list"}, "answer": "B", "difficulty": "medium"}
{"id": "py_022", "question": "Which statement about list comprehensions in Python 3 is correct?", "choices": {"A": "The loop variable leaks into the surrounding scope", "B": "They create a new local scope; the loop variable does not leak", "C": "They always create generators", "D": "They are slower than for-loops by definition"}, "answer": "B", "difficulty": "medium"}
{"id": "py_023", "question": "What is the recommended way to iterate with indices over a sequence?", "choices": {"A": "range(len(seq))", "B": "enumerate(seq)", "C": "zip(seq, range(len(seq)))", "D": "manually increment a counter"}, "answer": "B", "difficulty": "easy"}
{"id": "py_024", "question": "Converting a generator to a list does what to the generator?", "choices": {"A": "Clones it for multiple passes", "B": "Exhausts it", "C": "Makes it re-iterable", "D": "Turns it into a tuple only"}, "answer": "B", "difficulty": "easy"}
{"id": "py_025", "question": "Which blocks in try/except/else/finally always run?", "choices": {"A": "else only", "B": "finally only", "C": "except and else", "D": "try and else"}, "answer": "B", "difficulty": "easy"}
{"id": "py_026", "question": "What does __exit__(exc_type, exc, tb) returning True in a context manager indicate?", "choices": {"A": "Propagate the exception", "B": "Suppress the exception", "C": "Restart the with-block", "D": "Convert the exception to a warning"}, "answer": "B", "difficulty": "medium"}
{"id": "py_027", "question": "Which is a Pythonic approach to resource handling?", "choices": {"A": "LBYL: check then act for everything", "B": "EAFP: try the operation and handle exceptions", "C": "Use global variables to control access", "D": "Avoid exceptions entirely"}, "answer": "B", "difficulty": "easy"}
{"id": "py_028", "question": "Catching 'Exception' will NOT catch which of the following?", "choices": {"A": "ValueError", "B": "ZeroDivisionError", "C": "KeyboardInterrupt", "D": "RuntimeError"}, "answer": "C", "difficulty": "medium"}
{"id": "py_029", "question": "How do you chain exceptions to preserve the original traceback?", "choices": {"A": "raise NewError()", "B": "raise NewError from None", "C": "raise NewError from OriginalError", "D": "raise OriginalError from NewError"}, "answer": "C", "difficulty": "medium"}
{"id": "py_030", "question": "Which creates a set of unique squares from 0 to 9?", "choices": {"A": "{x*x for x in range(10)}", "B": "[x*x for x in range(10)]", "C": "(x*x for x in range(10))", "D": "dict(x=x*x for x in range(10))"}, "answer": "A", "difficulty": "easy"}
{"id": "py_031", "question": "What does s[::-1] do for a sequence s?", "choices": {"A": "Returns s unchanged", "B": "Returns a reversed shallow copy", "C": "Sorts s in place descending", "D": "Creates a deep copy"}, "answer": "B", "difficulty": "easy"}
{"id": "py_032", "question": "Which statement about slicing lists is correct?", "choices": {"A": "lst[:] returns a deep copy", "B": "lst[:] returns a shallow copy", "C": "lst[::2] mutates the list", "D": "lst[1:1] deletes the first element"}, "answer": "B", "difficulty": "medium"}
{"id": "py_033", "question": "Which comprehension creates a dictionary mapping unique items from iterable 'it' to their counts?", "choices": {"A": "{x: it.count(x) for x in it}", "B": "{x: x.count for x in it}", "C": "{x: it.count(x) for x in set(it)}", "D": "{x: 1 for x in it if x not in it}"}, "answer": "C", "difficulty": "hard"}
{"id": "py_034", "question": "Which comprehension best filters even numbers and squares them?", "choices": {"A": "[x**2 for x in xs if x % 2 == 0]", "B": "(x**2 if x % 2 == 0 for x in xs)", "C": "{x: x**2 if x % 2 == 0}", "D": "[x**2 if x % 2 == 0 else continue for x in xs]"}, "answer": "A", "difficulty": "easy"}
{"id": "py_035", "question": "When a module is imported, its top-level code executes:", "choices": {"A": "Every time it is imported", "B": "Only once per interpreter session due to sys.modules caching", "C": "Only when run as __main__", "D": "Never unless explicitly called"}, "answer": "B", "difficulty": "medium"}
{"id": "py_036", "question": "What does if __name__ == \"__main__\": commonly guard?", "choices": {"A": "Definitions that should import only", "B": "Code that should run when the module is executed as a script", "C": "Type annotations", "D": "Class definitions"}, "answer": "B", "difficulty": "easy"}
{"id": "py_037", "question": "Which is true about relative imports within a package?", "choices": {"A": "They are written with leading dots (e.g., from . import x)", "B": "They are deprecated and removed", "C": "They can refer to site-packages only", "D": "They imply executing __main__ block"}, "answer": "A", "difficulty": "medium"}
{"id": "py_038", "question": "In virtual environments, which statement is correct?", "choices": {"A": "They modify the global interpreter binaries", "B": "They provide isolated site-packages for a given interpreter", "C": "They require admin/root access", "D": "They cannot be used with pip"}, "answer": "B", "difficulty": "easy"}
{"id": "py_039", "question": "What does Optional[T] denote in the typing module?", "choices": {"A": "Union[T, int]", "B": "Union[T, T]", "C": "Union[T, None]", "D": "Only T, never None"}, "answer": "C", "difficulty": "easy"}
{"id": "py_040", "question": "Which typing module annotation means a variable may hold any type and skips type checking?", "choices": {"A": "Union", "B": "Any", "C": "TypeVar", "D": "NoReturn"}, "answer": "B", "difficulty": "medium"}
{"id": "py_041", "question": "In dataclasses, which is the correct way to set a mutable default list?", "choices": {"A": "field(default=[])", "B": "default=[] in class var", "C": "field(default_factory=list)", "D": "Set after __init__ in every instance"}, "answer": "C", "difficulty": "medium"}
{"id": "py_042", "question": "What does @dataclass(frozen=True) do?", "choices": {"A": "Prevents subclassing", "B": "Makes instances immutable (fields cannot be assigned)", "C": "Removes __init__", "D": "Disables hashing"}, "answer": "B", "difficulty": "medium"}
{"id": "py_043", "question": "Which is true about Protocols in typing?", "choices": {"A": "They enable structural subtyping by method presence", "B": "They enforce nominal inheritance only", "C": "They are runtime-only, no static benefit", "D": "They require abstract base classes"}, "answer": "A", "difficulty": "hard"}
{"id": "py_044", "question": "What does typing.Final suggest to type checkers?", "choices": {"A": "Variable is write-only", "B": "Variable should not be reassigned", "C": "Variable is local-only", "D": "Variable is deprecated"}, "answer": "B", "difficulty": "medium"}
{"id": "py_045", "question": "In CPython, the GIL ensures that:", "choices": {"A": "Multiple OS threads execute Python bytecode concurrently", "B": "Only one thread executes Python bytecode at a time", "C": "No I/O can happen in threads", "D": "Multiprocessing is disabled"}, "answer": "B", "difficulty": "easy"}
{"id": "py_046", "question": "For CPU-bound work in CPython, which is typically better for parallelism?", "choices": {"A": "threading", "B": "asyncio", "C": "multiprocessing", "D": "contextvars"}, "answer": "C", "difficulty": "medium"}
{"id": "py_047", "question": "Which statement about asyncio is correct?", "choices": {"A": "It is designed primarily for I/O-bound concurrency using event loops", "B": "It runs code on multiple CPU cores by default", "C": "It cannot interoperate with threads", "D": "It replaces the need for callbacks"}, "answer": "A", "difficulty": "medium"}
{"id": "py_048", "question": "Calling a blocking CPU-bound function directly inside an async function will:", "choices": {"A": "Be fine; the event loop will preempt it", "B": "Block the event loop", "C": "Automatically run in a thread pool", "D": "Raise a RuntimeError"}, "answer": "B", "difficulty": "medium"}
{"id": "py_049", "question": "Which is a correct way to run blocking work without freezing the event loop?", "choices": {"A": "await blocking_fn() directly", "B": "Use asyncio.sleep(0) in a loop", "C": "Use loop.run_in_executor or asyncio.to_thread", "D": "Use global variables"}, "answer": "C", "difficulty": "medium"}
{"id": "py_050", "question": "What is a common pitfall when sharing mutable objects across threads?", "choices": {"A": "They become read-only", "B": "Race conditions if not synchronized", "C": "They are copied to each thread automatically", "D": "They cannot be passed to threads"}, "answer": "B", "difficulty": "easy"}
{"id": "py_051", "question": "What is the pitfall of creating a 2D list with [[0]*3]*4?", "choices": {"A": "It creates a jagged list", "B": "All rows reference the same inner list", "C": "It uses too much memory", "D": "It sorts rows automatically"}, "answer": "B", "difficulty": "medium"}
{"id": "py_052", "question": "Which object is hashable and can be used as a dict key?", "choices": {"A": "list", "B": "set", "C": "frozenset", "D": "bytearray"}, "answer": "C", "difficulty": "easy"}
{"id": "py_053", "question": "What is the difference between a+b and a+=b for lists (typically in CPython)?", "choices": {"A": "Both always create a new list", "B": "a+=b extends in place; a+b creates a new list", "C": "a+=b creates a new list; a+b modifies in place", "D": "They are identical in all cases"}, "answer": "B", "difficulty": "medium"}
{"id": "py_054", "question": "Strings are immutable. What does s.replace('a','b') return?", "choices": {"A": "Modifies s in place", "B": "Returns a new string with replacements", "C": "Raises TypeError", "D": "Returns an iterator of changes"}, "answer": "B", "difficulty": "easy"}
{"id": "py_055", "question": "For dict d = {'a':[1]}, which makes a deep independent copy?", "choices": {"A": "d.copy()", "B": "copy.copy(d)", "C": "copy.deepcopy(d)", "D": "dict(d)"}, "answer": "C", "difficulty": "medium"}
{"id": "py_056", "question": "Which statement about list slicing assignment is correct?", "choices": {"A": "s[1:3] = [9,9] mutates s in place", "B": "s[1:3] returns a view into s", "C": "s[:] = t creates a new list", "D": "Slice assignment is not allowed"}, "answer": "A", "difficulty": "easy"}
{"id": "py_057", "question": "What does functools.wraps primarily preserve when writing decorators?", "choices": {"A": "Execution speed", "B": "Function metadata like __name__ and __doc__", "C": "Thread safety", "D": "Return type annotations only"}, "answer": "B", "difficulty": "easy"}
{"id": "py_058", "question": "Valid order markers for parameters are:", "choices": {"A": "positional-only '/', then params, then keyword-only '*'", "B": "'*' first then '/', then params", "C": "'/' and '*' can be in any order", "D": "Only one of '/' or '*' may appear"}, "answer": "A", "difficulty": "hard"}
{"id": "py_059", "question": "Keyword-only parameters are declared by:", "choices": {"A": "Placing them after a '*' in the signature", "B": "Placing them before '/'", "C": "Using **kwargs only", "D": "Using @keyword_only decorator"}, "answer": "A", "difficulty": "medium"}
{"id": "py_060", "question": "What does a bare 'raise' inside an except block do?", "choices": {"A": "Suppresses the exception", "B": "Reraises the current exception preserving traceback", "C": "Converts to RuntimeError", "D": "Logs and continues"}, "answer": "B", "difficulty": "easy"}
{"id": "py_061", "question": "Generator expression vs list comprehension: which uses less memory for large sequences?", "choices": {"A": "List comprehension", "B": "Generator expression", "C": "They are identical", "D": "Depends on GIL"}, "answer": "B", "difficulty": "easy"}
{"id": "py_062", "question": "Which method can send a value into a running generator at the 'yield' point?", "choices": {"A": "gen.push(value)", "B": "gen.inject(value)", "C": "gen.send(value)", "D": "next(gen, value)"}, "answer": "C", "difficulty": "hard"}
{"id": "py_063", "question": "What does generator.close() do?", "choices": {"A": "Consumes remaining values", "B": "Raises GeneratorExit inside the generator", "C": "Turns it into a list", "D": "Pauses it"}, "answer": "B", "difficulty": "medium"}
{"id": "py_064", "question": "Which itertools function is best to flatten multiple iterables without copying?", "choices": {"A": "itertools.product", "B": "itertools.chain", "C": "itertools.accumulate", "D": "itertools.repeat"}, "answer": "B", "difficulty": "easy"}
{"id": "py_065", "question": "Calling next(it, default) does what when it is exhausted?", "choices": {"A": "Raises StopIteration", "B": "Returns default instead of raising", "C": "Returns None and warns", "D": "Resets the iterator"}, "answer": "B", "difficulty": "easy"}
{"id": "py_066", "question": "In try/except/else/finally, when does 'else' run?", "choices": {"A": "Always", "B": "Only if an exception occurred", "C": "Only if no exception occurred in try", "D": "Only if finally runs"}, "answer": "C", "difficulty": "medium"}
{"id": "py_067", "question": "Ordering of except clauses should be:", "choices": {"A": "General to specific", "B": "Specific to general", "C": "Alphabetical", "D": "Random; interpreter sorts them"}, "answer": "B", "difficulty": "easy"}
{"id": "py_068", "question": "Which statement is true about contextlib.contextmanager?", "choices": {"A": "It turns a generator function into a context manager", "B": "It disables __enter__/__exit__", "C": "It only works with async functions", "D": "It requires metaclasses"}, "answer": "A", "difficulty": "medium"}
{"id": "py_069", "question": "What happens if __exit__ returns False (or None)?", "choices": {"A": "Suppress the exception", "B": "Propagate the exception after cleanup", "C": "Retry the block", "D": "Convert to warning"}, "answer": "B", "difficulty": "easy"}
{"id": "py_070", "question": "By default, iterating a dict d yields:", "choices": {"A": "Key-value pairs", "B": "Values", "C": "Keys", "D": "Indices"}, "answer": "C", "difficulty": "easy"}
{"id": "py_071", "question": "Which builds a dict mapping items to their counts most efficiently?", "choices": {"A": "{x: xs.count(x) for x in xs}", "B": "collections.Counter(xs)", "C": "{x: sum(1 for y in xs if y==x) for x in set(xs)}", "D": "dict.fromkeys(xs, 1)"}, "answer": "B", "difficulty": "medium"}
{"id": "py_072", "question": "What does dict.get(k, default) do?", "choices": {"A": "Raises KeyError if k missing", "B": "Returns default if k missing", "C": "Inserts default if k missing", "D": "Deletes key k"}, "answer": "B", "difficulty": "easy"}
{"id": "py_073", "question": "For defaultdict(list), accessing a missing key:", "choices": {"A": "Raises KeyError", "B": "Returns None", "C": "Creates the key with an empty list", "D": "Requires setdefault"}, "answer": "C", "difficulty": "medium"}
{"id": "py_074", "question": "Which statement about set comprehensions is correct?", "choices": {"A": "{x for x in xs} creates a list", "B": "{x for x in xs} removes duplicates by nature", "C": "They preserve order", "D": "They sort elements"}, "answer": "B", "difficulty": "easy"}
{"id": "py_075", "question": "__all__ in a module primarily controls:", "choices": {"A": "What import x exposes", "B": "What from x import * exports", "C": "What pip installs", "D": "Which names are picklable"}, "answer": "B", "difficulty": "medium"}
{"id": "py_076", "question": "Which statement about importlib.reload(module) is true?", "choices": {"A": "It clears sys.modules entirely", "B": "It re-executes the module's code and updates existing module object", "C": "It uninstalls the package", "D": "It restarts Python"}, "answer": "B", "difficulty": "hard"}
{"id": "py_077", "question": "What is the safest way to handle unknown text file encodings?", "choices": {"A": "Assume default open() encoding", "B": "Always use latin-1", "C": "Specify encoding explicitly (e.g., 'utf-8') and handle errors", "D": "Open in binary and decode blindly"}, "answer": "C", "difficulty": "medium"}
{"id": "py_078", "question": "PEP 585 (Python 3.9+) allows using built-in types as generics. Which syntax is valid?", "choices": {"A": "typing.List[int] only", "B": "list[int] and dict[str, int]", "C": "list<int>", "D": "List[T] requires from __future__ import annotations"}, "answer": "B", "difficulty": "medium"}
{"id": "py_079", "question": "What does typing.NoReturn indicate for a function?", "choices": {"A": "Returns None", "B": "Never returns normally (e.g., always raises or exits)", "C": "Not type-checked", "D": "Returns any type"}, "answer": "B", "difficulty": "medium"}
{"id": "py_080", "question": "Dataclass eq=True, frozen=False implies:", "choices": {"A": "Instances are immutable and hashable", "B": "__eq__ generated; mutability remains; __hash__ may be set to None", "C": "No __eq__ generated", "D": "__hash__ always auto-generated"}, "answer": "B", "difficulty": "hard"}
{"id": "py_081", "question": "Which typing construct narrows a variable after isinstance checks?", "choices": {"A": "TypeVar", "B": "Union", "C": "Literal", "D": "Type narrowing is done by type checkers based on control flow"}, "answer": "D", "difficulty": "medium"}
{"id": "py_082", "question": "For I/O-bound tasks with many sockets, which is typically appropriate?", "choices": {"A": "threading + blocking I/O", "B": "asyncio with non-blocking I/O", "C": "multiprocessing", "D": "contextvars"}, "answer": "B", "difficulty": "medium"}
{"id": "py_083", "question": "Which is thread-safe in the standard library for producer/consumer patterns?", "choices": {"A": "list", "B": "dict", "C": "queue.Queue", "D": "set"}, "answer": "C", "difficulty": "easy"}
{"id": "py_084", "question": "asyncio.gather(a(), b()) does what?", "choices": {"A": "Runs a then b sequentially", "B": "Schedules them concurrently and waits for both", "C": "Creates threads", "D": "Cancels both immediately"}, "answer": "B", "difficulty": "easy"}
{"id": "py_085", "question": "Which is a correct way to schedule a coroutine to run concurrently?", "choices": {"A": "await coro() immediately", "B": "asyncio.create_task(coro())", "C": "time.sleep in async function", "D": "Use global variables"}, "answer": "B", "difficulty": "medium"}
{"id": "py_086", "question": "Which prevents multiple threads from entering a critical section simultaneously?", "choices": {"A": "threading.Lock", "B": "threading.Timer", "C": "itertools.count", "D": "asyncio.sleep"}, "answer": "A", "difficulty": "easy"}
{"id": "py_087", "question": "@property on a method defines:", "choices": {"A": "A classmethod", "B": "A staticmethod", "C": "A managed attribute accessed like a field", "D": "A coroutine"}, "answer": "C", "difficulty": "easy"}
{"id": "py_088", "question": "__getattr__(self, name) is called when:", "choices": {"A": "Every attribute access", "B": "Only when normal attribute lookup fails", "C": "Before __getattribute__", "D": "For special methods only"}, "answer": "B", "difficulty": "medium"}
{"id": "py_089", "question": "Python MRO (multiple inheritance) uses which algorithm?", "choices": {"A": "Depth-first left-to-right", "B": "Breadth-first", "C": "C3 linearization", "D": "Randomized"}, "answer": "C", "difficulty": "hard"}
{"id": "py_090", "question": "Overriding __eq__ without defining __hash__ typically results in:", "choices": {"A": "Objects remain hashable", "B": "__hash__ is set to None, making instances unhashable", "C": "A SyntaxError", "D": "Automatic perfect hashing"}, "answer": "B", "difficulty": "medium"}
{"id": "py_091", "question": "Which is a security risk with pickle?", "choices": {"A": "It cannot represent custom classes", "B": "Unpickling untrusted data can execute arbitrary code", "C": "It only works in Python 2", "D": "It encrypts data by default"}, "answer": "B", "difficulty": "easy"}
{"id": "py_092", "question": "collections.deque is preferable to list when:", "choices": {"A": "You need fast appends/pops at both ends", "B": "You need random indexed access", "C": "You need sorting", "D": "You need slice assignment"}, "answer": "A", "difficulty": "easy"}
{"id": "py_093", "question": "Counter.most_common(1) returns:", "choices": {"A": "Only the count", "B": "A list of (element, count) pairs sorted by count", "C": "A set of top elements", "D": "Modifies the Counter to only one item"}, "answer": "B", "difficulty": "medium"}
{"id": "py_094", "question": "functools.lru_cache primarily improves performance by:", "choices": {"A": "Parallelizing function calls", "B": "Memoizing results of pure-ish functions", "C": "Converting functions to generators", "D": "Compiling to C"}, "answer": "B", "difficulty": "easy"}
{"id": "py_095", "question": "pathlib.Path('a') / 'b' does what?", "choices": {"A": "Performs integer division", "B": "Creates a new path 'a/b' using appropriate separator", "C": "Modifies the filesystem", "D": "Creates a symlink"}, "answer": "B", "difficulty": "easy"}
{"id": "py_096", "question": "unittest's assertRaises is typically used as:", "choices": {"A": "A decorator only", "B": "A context manager around the call that should raise", "C": "A try/except replacement that suppresses errors", "D": "A logging tool"}, "answer": "B", "difficulty": "medium"}
{"id": "py_097", "question": "Which statement about global and nonlocal is correct?", "choices": {"A": "global binds to nearest enclosing scope", "B": "nonlocal binds to nearest enclosing non-global scope; global binds to module scope", "C": "nonlocal creates a new variable in local scope", "D": "global and nonlocal are synonyms"}, "answer": "B", "difficulty": "medium"}
{"id": "py_098", "question": "Which operation on lists is O(1) average time?", "choices": {"A": "Insert at index 0", "B": "Append at the end", "C": "Insert in the middle", "D": "Remove from the front"}, "answer": "B", "difficulty": "easy"}
{"id": "py_099", "question": "What does bool(object) call under the hood?", "choices": {"A": "object.__repr__", "B": "object.__len__ then __bool__", "C": "object.__bool__ then __len__", "D": "hash(object)"}, "answer": "C", "difficulty": "hard"}
{"id": "py_100", "question": "Which description matches __slots__ in a class?", "choices": {"A": "Disables inheritance", "B": "Prevents adding attributes not listed and saves memory by skipping __dict__", "C": "Forces immutability", "D": "Makes instances hashable"}, "answer": "B", "difficulty": "medium"}